# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_stream_ietf_subscribed_notifications__streams_stream(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /streams/stream. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the built-in event streams that are supported by
the publisher.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__replay_support','__replay_log_creation_time','__replay_log_aged_time',)

  _yang_name = 'stream'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)
    self.__replay_support = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="replay-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='empty', is_config=False)
    self.__replay_log_creation_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-creation-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)
    self.__replay_log_aged_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-aged-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['streams', 'stream']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /streams/stream/name (string)

    YANG Description: A handle for a system-provided event stream made up of a
sequential set of event records, each of which is
characterized by its own domain and semantics.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /streams/stream/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A handle for a system-provided event stream made up of a
sequential set of event records, each of which is
characterized by its own domain and semantics.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /streams/stream/description (string)

    YANG Description: A description of the event stream, including such
information as the type of event records that are
available in this event stream.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /streams/stream/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A description of the event stream, including such
information as the type of event records that are
available in this event stream.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=False)


  def _get_replay_support(self):
    """
    Getter method for replay_support, mapped from YANG variable /streams/stream/replay_support (empty)

    YANG Description: Indicates that event record replay is available on this
event stream.
    """
    return self.__replay_support
      
  def _set_replay_support(self, v, load=False):
    """
    Setter method for replay_support, mapped from YANG variable /streams/stream/replay_support (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replay_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replay_support() directly.

    YANG Description: Indicates that event record replay is available on this
event stream.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="replay-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replay_support must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="replay-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='empty', is_config=False)""",
        })

    self.__replay_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replay_support(self):
    self.__replay_support = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="replay-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='empty', is_config=False)


  def _get_replay_log_creation_time(self):
    """
    Getter method for replay_log_creation_time, mapped from YANG variable /streams/stream/replay_log_creation_time (yang:date-and-time)

    YANG Description: The timestamp of the creation of the log used to support
the replay function on this event stream.  This time
might be earlier than the earliest available information
contained in the log.  This object is updated if the log
resets for some reason.
    """
    return self.__replay_log_creation_time
      
  def _set_replay_log_creation_time(self, v, load=False):
    """
    Setter method for replay_log_creation_time, mapped from YANG variable /streams/stream/replay_log_creation_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replay_log_creation_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replay_log_creation_time() directly.

    YANG Description: The timestamp of the creation of the log used to support
the replay function on this event stream.  This time
might be earlier than the earliest available information
contained in the log.  This object is updated if the log
resets for some reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-creation-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replay_log_creation_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-creation-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__replay_log_creation_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replay_log_creation_time(self):
    self.__replay_log_creation_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-creation-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)


  def _get_replay_log_aged_time(self):
    """
    Getter method for replay_log_aged_time, mapped from YANG variable /streams/stream/replay_log_aged_time (yang:date-and-time)

    YANG Description: The timestamp associated with the last event record that
has been aged out of the log.  This timestamp identifies
how far back in history this replay log extends, if it
doesn't extend back to the 'replay-log-creation-time'.
This object MUST be present if replay is supported and any
event records have been aged out of the log.
    """
    return self.__replay_log_aged_time
      
  def _set_replay_log_aged_time(self, v, load=False):
    """
    Setter method for replay_log_aged_time, mapped from YANG variable /streams/stream/replay_log_aged_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replay_log_aged_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replay_log_aged_time() directly.

    YANG Description: The timestamp associated with the last event record that
has been aged out of the log.  This timestamp identifies
how far back in history this replay log extends, if it
doesn't extend back to the 'replay-log-creation-time'.
This object MUST be present if replay is supported and any
event records have been aged out of the log.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-aged-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replay_log_aged_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-aged-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__replay_log_aged_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replay_log_aged_time(self):
    self.__replay_log_aged_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="replay-log-aged-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:date-and-time', is_config=False)

  name = __builtin__.property(_get_name)
  description = __builtin__.property(_get_description)
  replay_support = __builtin__.property(_get_replay_support)
  replay_log_creation_time = __builtin__.property(_get_replay_log_creation_time)
  replay_log_aged_time = __builtin__.property(_get_replay_log_aged_time)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('replay_support', replay_support), ('replay_log_creation_time', replay_log_creation_time), ('replay_log_aged_time', replay_log_aged_time), ])


class yc_streams_ietf_subscribed_notifications__streams(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /streams. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains information on the built-in event streams provided by
the publisher.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stream',)

  _yang_name = 'streams'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stream = YANGDynClass(base=YANGListType("name",yc_stream_ietf_subscribed_notifications__streams_stream, yang_name="stream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['streams']

  def _get_stream(self):
    """
    Getter method for stream, mapped from YANG variable /streams/stream (list)

    YANG Description: Identifies the built-in event streams that are supported by
the publisher.
    """
    return self.__stream
      
  def _set_stream(self, v, load=False):
    """
    Setter method for stream, mapped from YANG variable /streams/stream (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stream is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stream() directly.

    YANG Description: Identifies the built-in event streams that are supported by
the publisher.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_stream_ietf_subscribed_notifications__streams_stream, yang_name="stream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stream must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_stream_ietf_subscribed_notifications__streams_stream, yang_name="stream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=False)""",
        })

    self.__stream = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stream(self):
    self.__stream = YANGDynClass(base=YANGListType("name",yc_stream_ietf_subscribed_notifications__streams_stream, yang_name="stream", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=False)

  stream = __builtin__.property(_get_stream)


  _pyangbind_elements = OrderedDict([('stream', stream), ])


class yc_stream_filter_ietf_subscribed_notifications__filters_stream_filter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /filters/stream-filter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of preconfigured filters that can be applied to
subscriptions.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__stream_xpath_filter',)

  _yang_name = 'stream-filter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)
    self.__stream_xpath_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stream-xpath-filter", parent=self, choice=('filter-spec', 'stream-xpath-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:xpath1.0', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['filters', 'stream-filter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /filters/stream_filter/name (string)

    YANG Description: A name to differentiate between filters.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /filters/stream_filter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A name to differentiate between filters.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)


  def _get_stream_xpath_filter(self):
    """
    Getter method for stream_xpath_filter, mapped from YANG variable /filters/stream_filter/stream_xpath_filter (yang:xpath1.0)

    YANG Description: Event stream evaluation criteria encoded in the syntax of
an XPath 1.0 expression.

The XPath expression is evaluated on the representation of
individual, delineated event records as contained in
the event stream.

The result of the XPath expression is converted to a
boolean value using the standard XPath 1.0 rules.  If the
boolean value is 'true', the filter matches the event
record, and the event record is included in the
notification message sent to the receivers.

The expression is evaluated in the following XPath
context:

   o  The set of namespace declarations is the set of
      prefix and namespace pairs for all YANG modules
      implemented by the server, where the prefix is the
      YANG module name and the namespace is as defined by
      the 'namespace' statement in the YANG module.

      If the leaf is encoded in XML, all namespace
      declarations in scope on the 'stream-xpath-filter'
      leaf element are added to the set of namespace
      declarations.  If a prefix found in the XML is
      already present in the set of namespace
      declarations, the namespace in the XML is used.

   o  The set of variable bindings is empty.

   o  The function library is comprised of the core
      function library and the XPath functions defined in
      Section 10 in RFC 7950.

   o  The context node is the root node.
    """
    return self.__stream_xpath_filter
      
  def _set_stream_xpath_filter(self, v, load=False):
    """
    Setter method for stream_xpath_filter, mapped from YANG variable /filters/stream_filter/stream_xpath_filter (yang:xpath1.0)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stream_xpath_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stream_xpath_filter() directly.

    YANG Description: Event stream evaluation criteria encoded in the syntax of
an XPath 1.0 expression.

The XPath expression is evaluated on the representation of
individual, delineated event records as contained in
the event stream.

The result of the XPath expression is converted to a
boolean value using the standard XPath 1.0 rules.  If the
boolean value is 'true', the filter matches the event
record, and the event record is included in the
notification message sent to the receivers.

The expression is evaluated in the following XPath
context:

   o  The set of namespace declarations is the set of
      prefix and namespace pairs for all YANG modules
      implemented by the server, where the prefix is the
      YANG module name and the namespace is as defined by
      the 'namespace' statement in the YANG module.

      If the leaf is encoded in XML, all namespace
      declarations in scope on the 'stream-xpath-filter'
      leaf element are added to the set of namespace
      declarations.  If a prefix found in the XML is
      already present in the set of namespace
      declarations, the namespace in the XML is used.

   o  The set of variable bindings is empty.

   o  The function library is comprised of the core
      function library and the XPath functions defined in
      Section 10 in RFC 7950.

   o  The context node is the root node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="stream-xpath-filter", parent=self, choice=('filter-spec', 'stream-xpath-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:xpath1.0', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stream_xpath_filter must be of a type compatible with yang:xpath1.0""",
          'defined-type': "yang:xpath1.0",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stream-xpath-filter", parent=self, choice=('filter-spec', 'stream-xpath-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:xpath1.0', is_config=True)""",
        })

    self.__stream_xpath_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stream_xpath_filter(self):
    self.__stream_xpath_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stream-xpath-filter", parent=self, choice=('filter-spec', 'stream-xpath-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:xpath1.0', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  stream_xpath_filter = __builtin__.property(_get_stream_xpath_filter, _set_stream_xpath_filter)

  __choices__ = {'filter-spec': {'stream-xpath-filter': ['stream_xpath_filter']}}
  _pyangbind_elements = OrderedDict([('name', name), ('stream_xpath_filter', stream_xpath_filter), ])


class yc_filters_ietf_subscribed_notifications__filters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /filters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains a list of configurable filters that can be applied to
subscriptions.  This facilitates the reuse of complex filters
once defined.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stream_filter',)

  _yang_name = 'filters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stream_filter = YANGDynClass(base=YANGListType("name",yc_stream_filter_ietf_subscribed_notifications__filters_stream_filter, yang_name="stream-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['filters']

  def _get_stream_filter(self):
    """
    Getter method for stream_filter, mapped from YANG variable /filters/stream_filter (list)

    YANG Description: A list of preconfigured filters that can be applied to
subscriptions.
    """
    return self.__stream_filter
      
  def _set_stream_filter(self, v, load=False):
    """
    Setter method for stream_filter, mapped from YANG variable /filters/stream_filter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stream_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stream_filter() directly.

    YANG Description: A list of preconfigured filters that can be applied to
subscriptions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_stream_filter_ietf_subscribed_notifications__filters_stream_filter, yang_name="stream-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stream_filter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_stream_filter_ietf_subscribed_notifications__filters_stream_filter, yang_name="stream-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)""",
        })

    self.__stream_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stream_filter(self):
    self.__stream_filter = YANGDynClass(base=YANGListType("name",yc_stream_filter_ietf_subscribed_notifications__filters_stream_filter, yang_name="stream-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="stream-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)

  stream_filter = __builtin__.property(_get_stream_filter, _set_stream_filter)


  _pyangbind_elements = OrderedDict([('stream_filter', stream_filter), ])


class yc_receiver_ietf_subscribed_notifications__subscriptions_subscription_receivers_receiver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /subscriptions/subscription/receivers/receiver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A host intended as a recipient for the notification
messages of a subscription.  For configured
subscriptions, transport-specific network parameters
(or a leafref to those parameters) may be augmented to a
specific receiver in this list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__sent_event_records','__excluded_event_records','__state',)

  _yang_name = 'receiver'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)
    self.__sent_event_records = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="sent-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)
    self.__excluded_event_records = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="excluded-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {'value': 1}, 'suspended': {'value': 2}, 'connecting': {'value': 3}, 'disconnected': {'value': 4}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['subscriptions', 'subscription', 'receivers', 'receiver']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /subscriptions/subscription/receivers/receiver/name (string)

    YANG Description: Identifies a unique receiver for a subscription.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /subscriptions/subscription/receivers/receiver/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Identifies a unique receiver for a subscription.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)


  def _get_sent_event_records(self):
    """
    Getter method for sent_event_records, mapped from YANG variable /subscriptions/subscription/receivers/receiver/sent_event_records (yang:zero-based-counter64)

    YANG Description: The number of event records sent to the receiver.  The
count is initialized when a dynamic subscription is
established or when a configured receiver
transitions to the 'valid' state.
    """
    return self.__sent_event_records
      
  def _set_sent_event_records(self, v, load=False):
    """
    Setter method for sent_event_records, mapped from YANG variable /subscriptions/subscription/receivers/receiver/sent_event_records (yang:zero-based-counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sent_event_records is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sent_event_records() directly.

    YANG Description: The number of event records sent to the receiver.  The
count is initialized when a dynamic subscription is
established or when a configured receiver
transitions to the 'valid' state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="sent-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sent_event_records must be of a type compatible with yang:zero-based-counter64""",
          'defined-type': "yang:zero-based-counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="sent-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)""",
        })

    self.__sent_event_records = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sent_event_records(self):
    self.__sent_event_records = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="sent-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)


  def _get_excluded_event_records(self):
    """
    Getter method for excluded_event_records, mapped from YANG variable /subscriptions/subscription/receivers/receiver/excluded_event_records (yang:zero-based-counter64)

    YANG Description: The number of event records explicitly removed via
either an event stream filter or an access control
filter so that they are not passed to a receiver.
This count is set to zero each time
'sent-event-records' is initialized.
    """
    return self.__excluded_event_records
      
  def _set_excluded_event_records(self, v, load=False):
    """
    Setter method for excluded_event_records, mapped from YANG variable /subscriptions/subscription/receivers/receiver/excluded_event_records (yang:zero-based-counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_excluded_event_records is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_excluded_event_records() directly.

    YANG Description: The number of event records explicitly removed via
either an event stream filter or an access control
filter so that they are not passed to a receiver.
This count is set to zero each time
'sent-event-records' is initialized.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="excluded-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """excluded_event_records must be of a type compatible with yang:zero-based-counter64""",
          'defined-type': "yang:zero-based-counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="excluded-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)""",
        })

    self.__excluded_event_records = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_excluded_event_records(self):
    self.__excluded_event_records = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="excluded-event-records", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='yang:zero-based-counter64', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /subscriptions/subscription/receivers/receiver/state (enumeration)

    YANG Description: Specifies the state of a subscription from the
perspective of a particular receiver.  With this
information, it is possible to determine whether a
publisher is currently generating notification
messages intended for that receiver.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /subscriptions/subscription/receivers/receiver/state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Specifies the state of a subscription from the
perspective of a particular receiver.  With this
information, it is possible to determine whether a
publisher is currently generating notification
messages intended for that receiver.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {'value': 1}, 'suspended': {'value': 2}, 'connecting': {'value': 3}, 'disconnected': {'value': 4}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with enumeration""",
          'defined-type': "ietf-subscribed-notifications:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {'value': 1}, 'suspended': {'value': 2}, 'connecting': {'value': 3}, 'disconnected': {'value': 4}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {'value': 1}, 'suspended': {'value': 2}, 'connecting': {'value': 3}, 'disconnected': {'value': 4}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)

  name = __builtin__.property(_get_name, _set_name)
  sent_event_records = __builtin__.property(_get_sent_event_records)
  excluded_event_records = __builtin__.property(_get_excluded_event_records)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('name', name), ('sent_event_records', sent_event_records), ('excluded_event_records', excluded_event_records), ('state', state), ])


class yc_receivers_ietf_subscribed_notifications__subscriptions_subscription_receivers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /subscriptions/subscription/receivers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set of receivers in a subscription.
  """
  __slots__ = ('_path_helper', '_extmethods', '__receiver',)

  _yang_name = 'receivers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__receiver = YANGDynClass(base=YANGListType("name",yc_receiver_ietf_subscribed_notifications__subscriptions_subscription_receivers_receiver, yang_name="receiver", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="receiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['subscriptions', 'subscription', 'receivers']

  def _get_receiver(self):
    """
    Getter method for receiver, mapped from YANG variable /subscriptions/subscription/receivers/receiver (list)

    YANG Description: A host intended as a recipient for the notification
messages of a subscription.  For configured
subscriptions, transport-specific network parameters
(or a leafref to those parameters) may be augmented to a
specific receiver in this list.
    """
    return self.__receiver
      
  def _set_receiver(self, v, load=False):
    """
    Setter method for receiver, mapped from YANG variable /subscriptions/subscription/receivers/receiver (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receiver() directly.

    YANG Description: A host intended as a recipient for the notification
messages of a subscription.  For configured
subscriptions, transport-specific network parameters
(or a leafref to those parameters) may be augmented to a
specific receiver in this list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_receiver_ietf_subscribed_notifications__subscriptions_subscription_receivers_receiver, yang_name="receiver", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="receiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receiver must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_receiver_ietf_subscribed_notifications__subscriptions_subscription_receivers_receiver, yang_name="receiver", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="receiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)""",
        })

    self.__receiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receiver(self):
    self.__receiver = YANGDynClass(base=YANGListType("name",yc_receiver_ietf_subscribed_notifications__subscriptions_subscription_receivers_receiver, yang_name="receiver", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="receiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)

  receiver = __builtin__.property(_get_receiver, _set_receiver)


  _pyangbind_elements = OrderedDict([('receiver', receiver), ])


class yc_subscription_ietf_subscribed_notifications__subscriptions_subscription(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /subscriptions/subscription. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The identity and specific parameters of a subscription.
Subscriptions in this list can be created using a control
channel or RPC or can be established through configuration.

If the 'kill-subscription' RPC or configuration operations
are used to delete a subscription, a
'subscription-terminated' message is sent to any active or
suspended receivers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__transport','__encoding','__purpose','__source_interface','__source_vrf','__source_address','__configured_subscription_state','__receivers',)

  _yang_name = 'subscription'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='subscription-id', is_config=True)
    self.__transport = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='transport', is_config=True)
    self.__encoding = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='encoding', is_config=True)
    self.__purpose = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)
    self.__source_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-interface", parent=self, choice=('notification-message-origin', 'interface-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='if:interface-ref', is_config=True)
    self.__source_vrf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-vrf", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='leafref', is_config=True)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="source-address", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__configured_subscription_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'valid': {'value': 1}, 'invalid': {'value': 2}, 'concluded': {'value': 3}},), is_leaf=True, yang_name="configured-subscription-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)
    self.__receivers = YANGDynClass(base=yc_receivers_ietf_subscribed_notifications__subscriptions_subscription_receivers, is_container='container', yang_name="receivers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['subscriptions', 'subscription']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /subscriptions/subscription/id (subscription-id)

    YANG Description: Identifier of a subscription; unique in a given
publisher.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /subscriptions/subscription/id (subscription-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of a subscription; unique in a given
publisher.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='subscription-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with subscription-id""",
          'defined-type': "ietf-subscribed-notifications:subscription-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='subscription-id', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='subscription-id', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /subscriptions/subscription/transport (transport)

    YANG Description: For a configured subscription, this leaf specifies the
transport used to deliver messages destined for all
receivers of that subscription.  This object is
mandatory for subscriptions in the configuration
datastore.  This object (1) is not mandatory for dynamic
subscriptions in the operational state datastore and
(2) should not be present for other types of dynamic
subscriptions.
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /subscriptions/subscription/transport (transport)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: For a configured subscription, this leaf specifies the
transport used to deliver messages destined for all
receivers of that subscription.  This object is
mandatory for subscriptions in the configuration
datastore.  This object (1) is not mandatory for dynamic
subscriptions in the operational state datastore and
(2) should not be present for other types of dynamic
subscriptions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='transport', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with transport""",
          'defined-type': "ietf-subscribed-notifications:transport",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='transport', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='transport', is_config=True)


  def _get_encoding(self):
    """
    Getter method for encoding, mapped from YANG variable /subscriptions/subscription/encoding (encoding)

    YANG Description: The type of encoding for notification messages.  For a
dynamic subscription, if not included as part of an
'establish-subscription' RPC, the encoding will be populated
with the encoding used by that RPC.  For a configured
subscription, if not explicitly configured, the encoding
will be the default encoding for an underlying transport.
    """
    return self.__encoding
      
  def _set_encoding(self, v, load=False):
    """
    Setter method for encoding, mapped from YANG variable /subscriptions/subscription/encoding (encoding)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encoding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encoding() directly.

    YANG Description: The type of encoding for notification messages.  For a
dynamic subscription, if not included as part of an
'establish-subscription' RPC, the encoding will be populated
with the encoding used by that RPC.  For a configured
subscription, if not explicitly configured, the encoding
will be the default encoding for an underlying transport.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='encoding', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encoding must be of a type compatible with encoding""",
          'defined-type': "ietf-subscribed-notifications:encoding",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='encoding', is_config=True)""",
        })

    self.__encoding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encoding(self):
    self.__encoding = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-xml': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}, 'sn:encode-json': {'@module': 'ietf-subscribed-notifications', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications'}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='encoding', is_config=True)


  def _get_purpose(self):
    """
    Getter method for purpose, mapped from YANG variable /subscriptions/subscription/purpose (string)

    YANG Description: Open text allowing a configuring entity to embed the
originator or other specifics of this subscription.
    """
    return self.__purpose
      
  def _set_purpose(self, v, load=False):
    """
    Setter method for purpose, mapped from YANG variable /subscriptions/subscription/purpose (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purpose is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purpose() directly.

    YANG Description: Open text allowing a configuring entity to embed the
originator or other specifics of this subscription.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purpose must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)""",
        })

    self.__purpose = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purpose(self):
    self.__purpose = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='string', is_config=True)


  def _get_source_interface(self):
    """
    Getter method for source_interface, mapped from YANG variable /subscriptions/subscription/source_interface (if:interface-ref)

    YANG Description: References the interface for notification messages.
    """
    return self.__source_interface
      
  def _set_source_interface(self, v, load=False):
    """
    Setter method for source_interface, mapped from YANG variable /subscriptions/subscription/source_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_interface() directly.

    YANG Description: References the interface for notification messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="source-interface", parent=self, choice=('notification-message-origin', 'interface-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-interface", parent=self, choice=('notification-message-origin', 'interface-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__source_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_interface(self):
    self.__source_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-interface", parent=self, choice=('notification-message-origin', 'interface-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='if:interface-ref', is_config=True)


  def _get_source_vrf(self):
    """
    Getter method for source_vrf, mapped from YANG variable /subscriptions/subscription/source_vrf (leafref)

    YANG Description: VRF from which notification messages should egress a
publisher.
    """
    return self.__source_vrf
      
  def _set_source_vrf(self, v, load=False):
    """
    Setter method for source_vrf, mapped from YANG variable /subscriptions/subscription/source_vrf (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_vrf() directly.

    YANG Description: VRF from which notification messages should egress a
publisher.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="source-vrf", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_vrf must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-vrf", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='leafref', is_config=True)""",
        })

    self.__source_vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_vrf(self):
    self.__source_vrf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-vrf", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='leafref', is_config=True)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /subscriptions/subscription/source_address (inet:ip-address-no-zone)

    YANG Description: The source address for the notification messages.
If a source VRF exists but this object doesn't, a
publisher's default address for that VRF must
be used.
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /subscriptions/subscription/source_address (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: The source address for the notification messages.
If a source VRF exists but this object doesn't, a
publisher's default address for that VRF must
be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="source-address", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="source-address", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="source-address", parent=self, choice=('notification-message-origin', 'address-originated'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_configured_subscription_state(self):
    """
    Getter method for configured_subscription_state, mapped from YANG variable /subscriptions/subscription/configured_subscription_state (enumeration)

    YANG Description: The presence of this leaf indicates that the subscription
originated from configuration, not through a control
channel or RPC.  The value indicates the state of the
subscription as established by the publisher.
    """
    return self.__configured_subscription_state
      
  def _set_configured_subscription_state(self, v, load=False):
    """
    Setter method for configured_subscription_state, mapped from YANG variable /subscriptions/subscription/configured_subscription_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configured_subscription_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configured_subscription_state() directly.

    YANG Description: The presence of this leaf indicates that the subscription
originated from configuration, not through a control
channel or RPC.  The value indicates the state of the
subscription as established by the publisher.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'valid': {'value': 1}, 'invalid': {'value': 2}, 'concluded': {'value': 3}},), is_leaf=True, yang_name="configured-subscription-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configured_subscription_state must be of a type compatible with enumeration""",
          'defined-type': "ietf-subscribed-notifications:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'valid': {'value': 1}, 'invalid': {'value': 2}, 'concluded': {'value': 3}},), is_leaf=True, yang_name="configured-subscription-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)""",
        })

    self.__configured_subscription_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configured_subscription_state(self):
    self.__configured_subscription_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'valid': {'value': 1}, 'invalid': {'value': 2}, 'concluded': {'value': 3}},), is_leaf=True, yang_name="configured-subscription-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='enumeration', is_config=False)


  def _get_receivers(self):
    """
    Getter method for receivers, mapped from YANG variable /subscriptions/subscription/receivers (container)

    YANG Description: Set of receivers in a subscription.
    """
    return self.__receivers
      
  def _set_receivers(self, v, load=False):
    """
    Setter method for receivers, mapped from YANG variable /subscriptions/subscription/receivers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receivers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receivers() directly.

    YANG Description: Set of receivers in a subscription.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_receivers_ietf_subscribed_notifications__subscriptions_subscription_receivers, is_container='container', yang_name="receivers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receivers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_receivers_ietf_subscribed_notifications__subscriptions_subscription_receivers, is_container='container', yang_name="receivers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)""",
        })

    self.__receivers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receivers(self):
    self.__receivers = YANGDynClass(base=yc_receivers_ietf_subscribed_notifications__subscriptions_subscription_receivers, is_container='container', yang_name="receivers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  transport = __builtin__.property(_get_transport, _set_transport)
  encoding = __builtin__.property(_get_encoding, _set_encoding)
  purpose = __builtin__.property(_get_purpose, _set_purpose)
  source_interface = __builtin__.property(_get_source_interface, _set_source_interface)
  source_vrf = __builtin__.property(_get_source_vrf, _set_source_vrf)
  source_address = __builtin__.property(_get_source_address, _set_source_address)
  configured_subscription_state = __builtin__.property(_get_configured_subscription_state)
  receivers = __builtin__.property(_get_receivers, _set_receivers)

  __choices__ = {'notification-message-origin': {'interface-originated': ['source_interface'], 'address-originated': ['source_vrf', 'source_address']}}
  _pyangbind_elements = OrderedDict([('id', id), ('transport', transport), ('encoding', encoding), ('purpose', purpose), ('source_interface', source_interface), ('source_vrf', source_vrf), ('source_address', source_address), ('configured_subscription_state', configured_subscription_state), ('receivers', receivers), ])


class yc_subscriptions_ietf_subscribed_notifications__subscriptions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /subscriptions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains the list of currently active subscriptions, i.e.,
subscriptions that are currently in effect, used for
subscription management and monitoring purposes.  This
includes subscriptions that have been set up via
RPC primitives as well as subscriptions that have been
established via configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__subscription',)

  _yang_name = 'subscriptions'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subscription = YANGDynClass(base=YANGListType("id",yc_subscription_ietf_subscribed_notifications__subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['subscriptions']

  def _get_subscription(self):
    """
    Getter method for subscription, mapped from YANG variable /subscriptions/subscription (list)

    YANG Description: The identity and specific parameters of a subscription.
Subscriptions in this list can be created using a control
channel or RPC or can be established through configuration.

If the 'kill-subscription' RPC or configuration operations
are used to delete a subscription, a
'subscription-terminated' message is sent to any active or
suspended receivers.
    """
    return self.__subscription
      
  def _set_subscription(self, v, load=False):
    """
    Setter method for subscription, mapped from YANG variable /subscriptions/subscription (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscription is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscription() directly.

    YANG Description: The identity and specific parameters of a subscription.
Subscriptions in this list can be created using a control
channel or RPC or can be established through configuration.

If the 'kill-subscription' RPC or configuration operations
are used to delete a subscription, a
'subscription-terminated' message is sent to any active or
suspended receivers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_subscription_ietf_subscribed_notifications__subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscription must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_subscription_ietf_subscribed_notifications__subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)""",
        })

    self.__subscription = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscription(self):
    self.__subscription = YANGDynClass(base=YANGListType("id",yc_subscription_ietf_subscribed_notifications__subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='list', is_config=True)

  subscription = __builtin__.property(_get_subscription, _set_subscription)


  _pyangbind_elements = OrderedDict([('subscription', subscription), ])


class ietf_subscribed_notifications(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-subscribed-notifications - based on the path /ietf-subscribed-notifications. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for subscribing to event
records and receiving matching content in notification messages.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8639; see the
RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__streams','__filters','__subscriptions',)

  _yang_name = 'ietf-subscribed-notifications'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__streams = YANGDynClass(base=yc_streams_ietf_subscribed_notifications__streams, is_container='container', yang_name="streams", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)
    self.__filters = YANGDynClass(base=yc_filters_ietf_subscribed_notifications__filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)
    self.__subscriptions = YANGDynClass(base=yc_subscriptions_ietf_subscribed_notifications__subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_streams(self):
    """
    Getter method for streams, mapped from YANG variable /streams (container)

    YANG Description: Contains information on the built-in event streams provided by
the publisher.
    """
    return self.__streams
      
  def _set_streams(self, v, load=False):
    """
    Setter method for streams, mapped from YANG variable /streams (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_streams is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_streams() directly.

    YANG Description: Contains information on the built-in event streams provided by
the publisher.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_streams_ietf_subscribed_notifications__streams, is_container='container', yang_name="streams", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """streams must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_streams_ietf_subscribed_notifications__streams, is_container='container', yang_name="streams", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)""",
        })

    self.__streams = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_streams(self):
    self.__streams = YANGDynClass(base=yc_streams_ietf_subscribed_notifications__streams, is_container='container', yang_name="streams", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)


  def _get_filters(self):
    """
    Getter method for filters, mapped from YANG variable /filters (container)

    YANG Description: Contains a list of configurable filters that can be applied to
subscriptions.  This facilitates the reuse of complex filters
once defined.
    """
    return self.__filters
      
  def _set_filters(self, v, load=False):
    """
    Setter method for filters, mapped from YANG variable /filters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filters() directly.

    YANG Description: Contains a list of configurable filters that can be applied to
subscriptions.  This facilitates the reuse of complex filters
once defined.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filters_ietf_subscribed_notifications__filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filters_ietf_subscribed_notifications__filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)""",
        })

    self.__filters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filters(self):
    self.__filters = YANGDynClass(base=yc_filters_ietf_subscribed_notifications__filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)


  def _get_subscriptions(self):
    """
    Getter method for subscriptions, mapped from YANG variable /subscriptions (container)

    YANG Description: Contains the list of currently active subscriptions, i.e.,
subscriptions that are currently in effect, used for
subscription management and monitoring purposes.  This
includes subscriptions that have been set up via
RPC primitives as well as subscriptions that have been
established via configuration.
    """
    return self.__subscriptions
      
  def _set_subscriptions(self, v, load=False):
    """
    Setter method for subscriptions, mapped from YANG variable /subscriptions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscriptions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscriptions() directly.

    YANG Description: Contains the list of currently active subscriptions, i.e.,
subscriptions that are currently in effect, used for
subscription management and monitoring purposes.  This
includes subscriptions that have been set up via
RPC primitives as well as subscriptions that have been
established via configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_subscriptions_ietf_subscribed_notifications__subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscriptions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_subscriptions_ietf_subscribed_notifications__subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)""",
        })

    self.__subscriptions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscriptions(self):
    self.__subscriptions = YANGDynClass(base=yc_subscriptions_ietf_subscribed_notifications__subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications', defining_module='ietf-subscribed-notifications', yang_type='container', is_config=True)

  streams = __builtin__.property(_get_streams, _set_streams)
  filters = __builtin__.property(_get_filters, _set_filters)
  subscriptions = __builtin__.property(_get_subscriptions, _set_subscriptions)


  _pyangbind_elements = OrderedDict([('streams', streams), ('filters', filters), ('subscriptions', subscriptions), ])


